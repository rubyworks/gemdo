= Project Diary

== 2010-05-12 | File Store

One of the more "controversial" design decisions made by POM was to store all
metadata in a file store --one file per peice of information. But there is a
very specific reason for this. Namely that the version number needs to be
accessible indpendently of the other metadata so that it could be easily
updated. While the version could have been singled out, a few other fields were
related to the version number, for instance, the release date. In addition
other fields, such as the package name, are more commonly useful than
most of the other information and it seems wasteful to load up a large amount
of metadata for the sake of single entry. And so, taking all this into account,
the most consitant result was to put all entires in separate files.
There are plenty of advantages to this approach, as I have discussed else 
where, but their are also some unfortunate downsides. 

* Access of metadata via URL is hamperd since it takes multiple http requests to access the data.
* Having to edit multiple files is obviously not as convenient as editing a single file.
* Perhaps, worse of all, it simply strike some developers as "weird".

I have, for some time tried to work out a potential alternative design, one that
uses a small number of files, separating metadata according the needs mentioned
above. While I am not 100% on the exact names of the files, I have worked out 
taht this alternative would have two files:

* <tt>.package</tt> for name, version, release date, status, and also internal load path.
* <tt>.require</tt> for dependencies, devided into environment sections.
* <tt>.profile</tt> for all other metadata such as description, summary, authors, etc.

This system would work just as well as the per file system as far as the
separation of important concerns --the .package file would be updated regulalry
while the .profile file would change only rarely. I am tempted to support this
design, but I am a littel hestitant to break backward compatability and concerned
that future needs might prove this division of information more fragile than it
presently seems. That's one of the big advantages of the file store design
actually, adding new stuff to it has essentially no ramifications on the design.
POM could support both designs, but I worry this would only further complicate
matters.


== 2010-05-05 | Resourcess Subdirectory

To subdirectory or not to subdirectory? That is the question. Whether it is better
to separate relavent sets of information into their own little area of concern or
to leave them adrift within all the other metadata, it is a difficult choice.
On the one hand, the simplicity of a single depth store is very attractive, on the
other the sepration of concerns leads to a cleaner layout. And then I must ask,
how far does it go? Does separating "requirements", like +requires+, +provides+,
and so on, into a separate subdirectory, make more sense as well?


== 2010-01-17 | Wiki's are the best User Manuals

Today I have finally decided that a Wiki is the best place
to keep user documentation. There is of course the obvious
advantage to this: online access, editable by any user, anywhere
at anytime. There are some subtle advantages as well. For instance,
I get automatic spell-checking via my browser.

Of course the big disadvantage is that should the Wiki Host
go kaputz, then no more documentation. I trust GitHub is not
going anywhere anytime soon, but I have had such a thing happen
to me before so I will be sure to look into making backups just in case.


== 2010-01-16 | Build Metadata

Debated a long time about what to do about "build metadata".
At issue is the fact that it is almost entirely information that
the end-user never needs to see, so it does not need to be
shipped with the package(s), as regular metadata generally
does. So this build data doesn't belong in the same location
as the regular metadata --with one exception. Build requirements
to actually compile and install the pacakge are needed.

After much consideration I have decided that such build requirements
should be included in the regular requirements field when
they are needed to compile and/or install.

As for the rest, I have for now at least declared a YAGNI.
The build fields would only act as defaults for other tools in
anycase. One might as well provide the configuration settings
for the tools themselves (e.g. setting them in a Rakefile).

